<h2 class="article-title">Introduction</h2>
<p>
    The CEMC servers were DDOS'd on the day of the CCC, so they had another contest to decide CCO invitees. Here is my analysis on the problems:
</p>

<h2 class="article-title">P1: Stupendous Bowties</h2>
<h3>Analysis</h3>

<p>
    You can only make a bowtie given five points \(p_1, p_2, p_3, p_4, p_5\) if they meet the following four conditions: 
    $$  p_{1x} = p_{2x} = p_{3x}\\
        p_{4y} = p_{5y} = p_{3x}\\
        p_{4x} < p_{3x} < p_{5x}\\
        p_{1y} < p_{3y} < p_{2y}$$
</p>

<p>
    In other words, a naive solution would find the points above, below, to the right, and to the left of point \(p\). The number of valid bowties would be \(2*\text{above}*\text{below}*\text{right}*\text{left}\).
</p>

<p>
    To speed the algorithm up, we can put each point \(p\) in buckets representing unique x coordinates and y coordinates. By sorting each bucket, we can then find the number of valid bowties with point \(p\) at the center.
    
<p>
    Time complexity: \(O(N\ log\ N)\)
</p>

<a href="https://github.com/jeffrey-xiao/Competitive-Programming/blob/master/src/contest/ccc/CCOQR_2016_P1.java">Link to Code</a>

<h2 class="article-title">P2: Through A Maze Darkly</h2>
<h3>Analysis</h3>

<p>
    Let us denote a position as the next corrider you will enter, walking on the right side of the wall. Continuously walking along the right side of a wall will yield in a cycle and cause you to return to your starting position. However, it is possible that you may enter your starting room more than once.
</p>

<p>
    Because the number of cycles in the graph is proportional to \(M\), the number of edges, we can traverse all possible cycles in the graph and determine the longest cycles for each room.
</p>

<p>
    In order to implement this, you can use a adjacency map where each edge maps to the next clockwise edge. While traversing each cycle, maintain two arrays that track the first time a room has been entered and the last time a room has been entered. Using these arrays, you can determine all the room cycle lengths. The maximum of them will be your answer.
<p>
    Time complexity: \(O(NM)\)
</p>

<a href="https://github.com/jeffrey-xiao/Competitive-Programming/blob/master/src/contest/ccc/CCOQR_2016_P2.java">Link to Code</a>

<h2 class="article-title">P3: Data Structure</h2>
<h3>Analysis</h3>

<p>
    Visualize the triangle as a right-angled triangle. For example, the input would look like this:
</p>

<div style="text-align: center">
<code-snippet>0
00
100
0001
00000
010000</code-snippet>
</div>

<p>
    We can then do a line sweep and calculate the area of the trapezoids to figure out the minimum data needed. The height of the current column will be \(max(\text{curr height}, \text{prev height - dist})\). The area between the current column and previous column will be the sum of the triangle and square.
</p>

<p>
    Time complexity: \(O(M\ log \ M)\)
</p>

<a href="https://github.com/jeffrey-xiao/Competitive-Programming/blob/master/src/contest/ccc/CCOQR_2016_P3.java">Link to Code</a>